# -*- coding: utf-8 -*-
"""Wildfire Prediction Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ASJ3C0tL-Zngdh16G5Ig6OsrxXlfOym8

#Climate Conditions

##Load & Clean Data
"""

!pip install kagglehub
import kagglehub
import pandas as pd
import os
path1 = kagglehub.dataset_download("ayoubjadouli/morocco-wildfire-predictions-2010-2022-ml-dataset") #Dataset ‡∏à‡∏≤‡∏Å Jadouli, A. (2023). *Morocco Wildfire Predictions (2010-2022) ML Dataset* [Data set]. Kaggle. https://www.kaggle.com/datasets/ayoubjadouli/morocco-wildfire-predictions-2010-2022-ml-dataset
file_path = os.path.join(path1, 'Date_final_dataset_balanced_float32.parquet')
df = pd.read_parquet(file_path)
df = df.head(20000)

df = df[['latitude','longitude','NDVI','average_temperature_lag_1', 'precipitation_lag_1','dew_point_lag_1','wind_speed_lag_1','is_fire','acq_date']].rename(columns={
    'average_temperature_lag_1': 'Temperature',
    'precipitation_lag_1': 'Precipitation',
    'dew_point_lag_1': 'Humidity',
    'wind_speed_lag_1': 'Windspeed',
    'acq_date': 'Date'})
df["Temperature"] = (df["Temperature"] - 32) * 5.0/9.0
df.rename(columns={"Temperature": "Temperature"}, inplace=True)

df.head(10)

df['Date'] = pd.to_datetime(df['Date'])

df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month
df['Day'] = df['Date'].dt.day

df = df.drop('Date', axis=1)

print(df.head())

"""#Train Data"""

from sklearn.model_selection import train_test_split

X = df.drop('is_fire', axis=1)
y = df['is_fire']

X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42)

print("Train set shape:", X_train.shape, y_train.shape)
print("Validation set shape:", X_val.shape, y_val.shape)
print("Test set shape:", X_test.shape, y_test.shape)

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

y_pred = model.predict(X_val)

accuracy = accuracy_score(y_val, y_pred)
print(f"Validation Accuracy: {accuracy}")

from sklearn.metrics import confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

cm = confusion_matrix(y_val, y_pred)

plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues",
            xticklabels=['No Fire', 'Fire'], yticklabels=['No Fire', 'Fire'])
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("Confusion Matrix")
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
sns.heatmap(df.corr(), annot=True, cmap='coolwarm')
plt.title("Feature Correlation")
plt.show()

correlations = df.corr()["is_fire"].drop("is_fire").sort_values(ascending=False)

print("Features most positively related to wildfire:")
print(correlations.head())

print("\nFeatures most negatively related to wildfire:")
print(correlations.tail())

import seaborn as sns
sns.boxplot(data=df, x='is_fire', y='latitude')

!git clone https://github.com/opjns/Wildfire-prediction.git

import os

image_dir = "/content/Wildfire-prediction/Images/Train"

print("Sample images:")
print(os.listdir(image_dir)[:5])

import torch
from torchvision import datasets, transforms
from torch.utils.data import DataLoader

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor()
])

dataset = datasets.ImageFolder(root=image_dir, transform=transform)

data_loader = DataLoader(dataset, batch_size=32, shuffle=True)

print("Classes:", dataset.classes)

import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(3, 16, 3)
        self.pool = nn.MaxPool2d(2)
        self.fc1 = nn.Linear(16 * 111 * 111, 2)

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = x.view(-1, 16 * 111 * 111)
        x = self.fc1(x)
        return x

model = SimpleCNN()

import torch.optim as optim

# Use GPU if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = model.to(device)

# Loss and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
epochs = 5
for epoch in range(epochs):
    running_loss = 0.0
    correct = 0
    total = 0

    for images, labels in data_loader:
        images, labels = images.to(device), labels.to(device)

        # Forward + backward + optimize
        outputs = model(images)
        loss = criterion(outputs, labels)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        # Statistics
        running_loss += loss.item()
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

    acc = 100 * correct / total
    print(f"Epoch [{epoch+1}/{epochs}] Loss: {running_loss:.3f} | Accuracy: {acc:.2f}%")

from torchvision import datasets, transforms
from torch.utils.data import DataLoader

valid_dir = "/content/Wildfire-prediction/Images/Valid"

transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor()
])

valid_dataset = datasets.ImageFolder(root=valid_dir, transform=transform)
valid_loader = DataLoader(valid_dataset, batch_size=32, shuffle=False)

import torch

model.eval()
correct = 0
total = 0

with torch.no_grad():
    for images, labels in valid_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

val_accuracy = 100 * correct / total
print(f"Validation Accuracy: {val_accuracy:.2f}%")

import matplotlib.pyplot as plt
model.eval()
y_pred_cnn_list = []
y_true_cnn_list = []

with torch.no_grad():
    for images, labels in valid_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, predicted = torch.max(outputs, 1)
        y_pred_cnn_list.extend(predicted.cpu().numpy())
        y_true_cnn_list.extend(labels.cpu().numpy())

cm_cnn = confusion_matrix(y_true_cnn_list, y_pred_cnn_list)

# Confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_cnn, annot=True, fmt="d", cmap="Blues",
            xticklabels=valid_dataset.classes, yticklabels=valid_dataset.classes)
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.title("CNN Confusion Matrix")
plt.show()

import joblib
joblib.dump(model, 'wildfire_model.py')

!pip install streamlit
import streamlit as st
import pandas as pd
import joblib
from PIL import Image
import numpy as np

st.title("Wildfire Prediction")

model = joblib.load("wildfire_model.py")

#Input
st.header("Enter Environmental Data")
lat = st.number_input("Latitude")
lon = st.number_input("Longitude")
ndvi = st.number_input("NDVI")
temp = st.number_input("Temperature (¬∞C)", -20.0, 60.0)
humidity = st.slider("Humidity (%)", 0, 100)
day = st.number_input("Day", 1, 31, step=1)
month = st.number_input("Month", 1, 12, step=1)
year = st.number_input("Year")

# Image
st.header("Upload Satellite Image")
image_file = st.file_uploader("Upload satellite image", type=["jpg", "jpeg", "png"])
image_features = []

if image_file:
    image = Image.open(image_file).convert("RGB")
    image = image.resize((64, 64))
    st.image(image, caption="Uploaded Satellite Image", use_column_width=True)

    image_array = np.array(image) / 255.0
    image_features = image_array.flatten()

# Predict button
if st.button("Predict Wildfire Risk"):
    tabular_features = [lat, lon, ndvi, temp, humidity, day, month, year]
    final_input = np.array(tabular_features + list(image_features)).reshape(1, -1)

    prediction = model.predict(final_input)[0]
    confidence = model.predict_proba(final_input)[0][1]  # Probability of class 1 (fire)

    st.markdown(f"### üîç Prediction: **{'Risk of Wildfire' if prediction == 1 else 'No Wildfire'}**")
    st.markdown(f"### üìà Confidence Level: **{confidence*100:.2f}%**")

    if prediction == 1:
        st.warning("üö® **Safety Precautions**:\n- Avoid open flames\n- Report smoke or fire immediately\n- Keep emergency supplies ready\n- Stay updated with local alerts\n- Prepare evacuation plans")

!streamlit run wildfire_model.py